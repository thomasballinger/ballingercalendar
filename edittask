#!/projects/schiz/software/LabPython/Python-2.6.3/python
# edittask
# being updated for use with spreadsheet-based tasks
# thomasballinger@gmail.com

import os, sys, optparse
sys.path = ['/projects/schiz/ra/tomb/python']+sys.path+['/projects/schiz/ra/tomb/scripts']
import datetime, parse
import spreadsheetTask as task
origDir = os.getcwd()
scriptFile = os.path.abspath(__file__)
scriptDir = os.path.basename(scriptFile)
import cmd
from pprint import pprint

class EditTasksCLI(cmd.Cmd):
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.prompt = ':) '
        self.selectedTask = None
        self.taskList = task.createTasks()

    def do_updateLocalTasklist(self, arg):
        self.taskList = task.createTasks()

    def do_exit(self, arg):
        sys.exit(0)

    def do_quit(self, arg):
        sys.exit(0)

    def do_EOF(self, arg):
        print('')
        return True

    def do_listtasks(self, arg):
        print self.taskList

    def do_task(self, arg):
        if arg:
            l = [x for x in self.taskList if x.name == arg]
            if not l:
                print('no such task')
                return
            self.selectedTask = l[0]
            print(self.selectedTask)
        elif self.selectedTask:
            print(self.selectedTask)
        else:
            print('select a task, or create a new one')

    def complete_task(self, text, line, beginindex, endindex):
        if not text:
            return [x.name for x in [t.name for t in self.taskList]]
        else:
            return [x.name for x in [t.name for t in self.taskList] if x.name.startswith(text)]

    def do_rename(self,arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        self.selectedTask.isCompleted = True
        self.selectedTask.put()

    def do_newtask(self,arg):
        if not arg:
            arg = raw_input('task name:')
            if not arg:
                print('nm')
                return False
        t = task.newTask(arg)
        self.selectedTask = t
        self.selectedTask.put()

    def do_description(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        if not arg:
            pprint('description:'+self.selectedTask.description)
            return
        self.selectedTask.description = arg
        self.selectedTask.put()

    def do_due(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        if not arg:
            print'due date:',self.selectedTask.duedate
            return
        time = parse.parseDate(arg)
        self.selectedTask.duedate = time
        print 'due date:',time
        task.saveTask(self.selectedTask)

    def do_assigner(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        if not arg:
            print 'assigner:',self.selectedTask.assigner
            return
        self.selectedTask.assigner = arg
        self.selectedTask.put()

    def do_priority(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        if not arg:
            print 'priority:',self.selectedTask.priority
            return
        if not -1<int(arg)<10:
            print('bad priority value')
            return
        self.selectedTask.priority = int(arg)
        self.selectedTask.put()

    def do_estimatedTime (self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        if not arg:
            print 'estimated time:',self.selectedTask.estimatedTime
            return
        timedelta = parse.parseTimedelta(arg)
        self.selectedTask.estimatedTime = timedelta
        self.selectedTask.put()
        print 'estimated time:',self.selectedTask.estimatedTime

    def do_timeSpent(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        if not arg:
            print 'time spend:',self.selectedTask.timeSpent
            return
        interval = parse.parseTimeInterval(arg)
        self.selectedTask.timeSpend.append()
        self.selectedTask.put()
        print 'time spend:',self.selectedTask.timeSpent

    def do_wait(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        if not arg:
            print 'waits:',self.selectedTask.waits
            return
        self.selectedTask.waits.append(task.Wait())
        self.selectedTask.waits[-1].whatFor = arg
        selectedTask.put()
        print 'waits:',self.selectedTask.waits

    def do_appointment(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        self.selectedTask.isAppointment = True
        self.selectedTask.put()
        print 'task is now an appointment'

    def do_notAppointment(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        self.selectedTask.isAppointment = False
        self.selectedTask.put()
        print 'task is now not an appointment'

    def do_notComplete(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        self.selectedTask.isComplete = False
        self.selectedTask.put()

    def do_complete(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        self.selectedTask.isComplete = True
        self.selectedTask.put()

    def do_showCurrentTask(self, arg):
        if not self.selectedTask:
            print 'select a task first'
            return
        t = self.selectedTask
        print(t.name)
        for (label,prop) in zip(['desc:','due:','assigned by:','priority:','time estimate:','time spent','start time','waits','is appointment:','is complete:'],[t.description, t.duedate, t.assigner, t.priority, t.estimatedTime, t.timeSpent, t.startTime, t.waits, t.isAppointment, t.isCompleted]):
            if prop:
                print label,prop

    def do_removeTask(self, arg):
        if not self.selectedTask:
            print 'select a task first'
            return
        check = parse.parseBoolean(raw_input('really delete task'+self.selectedTask.__repr__()+'?\n'))
        if check:
            task.deleteTask(self.selectedTask)
            self.selectedTask = None

    def do_listChronologicallyByDueDate(self, arg):
        pprint(task.getTheStack(task.loadTasks()))

    def do_listOverdue(self, arg):
        pprint([t for t in self.taskList if t.duedate < datetime.datetime.now()])

    def do_graphTasks(self, arg):
        pass

    def do_workedOn(self, arg):
        "doesn't do anything yet"
        return parse.parseTimeInterval(arg)

if __name__ == '__main__':
    cli = EditTasksCLI()
    cli.cmdloop()
