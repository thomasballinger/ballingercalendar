#!/usr/bin/python
# edittask
# being updated for use with spreadsheet-based tasks
# thomasballinger@gmail.com
import time
import os, sys, optparse
import datetime, parse
import spreadsheetByListTask as task
import calendarHours as hours
origDir = os.getcwd()
scriptFile = os.path.abspath(__file__)
scriptDir = os.path.basename(scriptFile)
import cmd
from pprint import pprint

class EditTasksCLI(cmd.Cmd):
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.prompt = ':) '
        self.selectedTask = None
        self.taskList = task.createTasks()

    def do_updateLocalTasklist(self, arg):
        self.taskList = task.createTasks()

    def do_exit(self, arg):
        sys.exit(0)

    def do_quit(self, arg):
        sys.exit(0)

    def do_EOF(self, arg):
        print('')
        return True

    def do_listtasks(self, arg):
        print self.taskList

    def do_task(self, arg):
        if arg:
            arg = arg.replace('_',' ')
            l = [x for x in self.taskList if x.name == arg]
            if not l:
                print('no such task')
                return
            self.selectedTask = l[0]
            print(self.selectedTask)
        elif self.selectedTask:
            print(self.selectedTask)
        else:
            print('select a task, or create a new one')

    def complete_task(self, text, line, beginindex, endindex):
        if not text:
            a = [x.name.replace(' ','_') for x in self.taskList]
            return a
        else:
            a = [x.name.replace(' ','_') for x in [t for t in self.taskList if text.lower() in t.name.replace(' ','_').lower()]]
            return a

    def do_rename(self,arg):
        if not self.selectedTask: print('choose a task first'); return
        self.selectedTask.name = arg.replace('_',' ')
        self.selectedTask.put()
        self.taskList = task.createTasks()

    def do_newtask(self,arg):
        if not arg:
            arg = raw_input('task name:')
            if not arg:
                print('nm')
                return False
        t = task.newTask(arg.replace('_',' '))
        self.selectedTask = t
        time.sleep(1)

    def do_description(self, arg):
        if not self.selectedTask: print('choose a task first'); return
        if not arg:
            print('description:'+self.selectedTask.description)
            return
        self.selectedTask.description = arg
        self.selectedTask.put()
        self.taskList = task.createTasks()

    def do_timeLeft(self, arg):
        """Displays time left before a task is due, """
        if not self.selectedTask: print('choose a task first'); return
        self.selectedTask.timespent = hours.getHoursWorked(self.selectedTask.id)
        overdue = self.selectedTask.duedate - datetime.datetime.now()
        left = self.selectedTask.estimatedtime - self.selectedTask.timespent
        if self.selectedTask.iscompleted:
            print 'task completed.'
            print 'estimated time for task:      ', self.selectedTask.estimatedtime
            print 'time spent on task:           ', self.selectedTask.timespent
        else:
            if overdue < datetime.timedelta(0):
                print 'task overdue by:          ', abs(overdue)
            else:
                print 'time until task due:      ', overdue
            if left < datetime.timedelta(0):
                print 'task is overbudget by:    ', abs(left)
            else:
                print 'estimated time to complete', left
            print     'estimated time for task:  ', self.selectedTask.estimatedtime
            print     'time spent so far:        ', self.selectedTask.timespent

    def do_due(self, arg):
        if not self.selectedTask: print('choose a task first'); return
        if not arg:
            print 'due date:',self.selectedTask.duedate
            return
        time = parse.parseDate(arg)
        self.selectedTask.duedate = time
        print 'due date:',time
        self.selectedTask.put()
        self.taskList = task.createTasks()

    def do_assigner(self, arg):
        if not self.selectedTask: print('choose a task first'); return
        if not arg:
            print 'assigner:',self.selectedTask.assigner
            return
        self.selectedTask.assigner = arg
        self.selectedTask.put()
        self.taskList = task.createTasks()

    def do_whose(self, arg):
        if not self.selectedTask: print('choose a task first'); return
        if not arg:
            print 'whose:',self.selectedTask.whose
            return
        self.selectedTask.whose = arg
        self.selectedTask.put()
        self.taskList = task.createTasks()

    def do_priority(self, arg):
        if not self.selectedTask: print('choose a task first'); return
        if not arg:
            print 'priority:',self.selectedTask.priority
            return
        if not -1<int(arg)<10:
            print('bad priority value')
            return
        self.selectedTask.priority = int(arg)
        self.selectedTask.put()
        self.taskList = task.createTasks()

    def do_estimatedTime (self, arg):
        if not self.selectedTask: print('choose a task first'); return
        if not arg:
            print 'estimated time:',self.selectedTask.estimatedtime
            return
        timedelta = parse.parseTimedelta(arg)
        self.selectedTask.estimatedtime = timedelta
        self.selectedTask.put()
        self.taskList = task.createTasks()
        print 'estimated time:',self.selectedTask.estimatedtime

    def do_timeSpent(self, arg):
        if not self.selectedTask: print('choose a task first'); return
        if not arg:
            print 'time spend:',self.selectedTask.timeSpent
            return
        interval = parse.parseTimeInterval(arg)
        self.selectedTask.timeSpend.append()
        self.selectedTask.put()
        self.taskList = task.createTasks()
        print 'time spend:',self.selectedTask.timeSpent

    def do_wait(self, arg):
        if not self.selectedTask: print('choose a task first'); return
        if not arg:
            print 'waits:',self.selectedTask.waits
            return
        self.selectedTask.waits.append(task.Wait())
        self.selectedTask.waits[-1].whatFor = arg
        selectedTask.put()
        print 'waits:',self.selectedTask.waits

    def do_appointment(self, arg):
        if not self.selectedTask: print('choose a task first'); return
        self.selectedTask.isappointment = True
        self.selectedTask.put()
        self.taskList = task.createTasks()
        print 'task is now an appointment'

    def do_notAppointment(self, arg):
        if not self.selectedTask: print('choose a task first'); return
        self.selectedTask.isappointment = False
        self.selectedTask.put()
        self.taskList = task.createTasks()
        print 'task is now not an appointment'

    def do_notComplete(self, arg):
        if not self.selectedTask: print('choose a task first'); return
        self.selectedTask.iscompleted= False
        self.selectedTask.put()
        self.taskList = task.createTasks()

    def do_complete(self, arg):
        if not self.selectedTask: print('choose a task first'); return
        self.selectedTask.iscompleted= True
        self.selectedTask.put()
        self.taskList = task.createTasks()

    def do_showCurrentTask(self, arg):
        if not self.selectedTask: print 'select a task first'; return
        t = self.selectedTask
        print(t.name)
        for (label,prop) in zip(
        ['desc:','due:','assigned by:','priority:','time estimate:','time spent','start time','waits','is appointment:','is complete:'],
        [t.description, t.duedate, t.assigner, t.priority, t.estimatedtime, t.timespent, t.starttime, t.waitids, t.isappointment, t.iscompleted]):
            if prop:
                print label,prop

    def do_removeTask(self, arg):
        if not self.selectedTask: print 'select a task first'; return
        check = parse.parseBoolean(raw_input('really delete task'+self.selectedTask.__repr__()+'?\n'))
        if check:
            task.deleteTask(self.selectedTask)
            self.selectedTask = None

    def do_listChronologicallyByDueDate(self, arg):
        pprint(task.getTheStack(self.taskList))

    def do_listOverdue(self, arg):
        pprint([t for t in self.taskList if t.duedate < datetime.datetime.now() and not t.iscompleted])

    def do_listCompleted(self, arg):
        pprint([t for t in self.taskList if t.iscompleted])

    def do_listInProgress(self, arg):
        
        taskList = [t for t in self.taskList if not t.iscompleted]
        taskList.sort(key=lambda t: datetime.timedelta(t.priority*365*10) + (t.duedate - datetime.datetime.now()))
        maxTaskLength = max(len(t.name) for t in taskList)
        print ('task name'+' '*maxTaskLength)[:maxTaskLength]+ ' p' + '   ' + 'time left' + '   ' + 'time till due'
        for t in taskList:
            timeToGo = self.timedeltaToHoursString(t.estimatedtime - t.timespent)
            timeTillDue = self.timedeltaToDaysString(t.duedate - datetime.datetime.now())
            print (t.name + ' '*maxTaskLength)[:maxTaskLength]+' '+str(t.priority)+'   '+(timeToGo+' '*10)[:10]+timeTillDue

    def do_listProjects(self, arg):
        taskList = [t for t in self.taskList if not t.iscompleted]
        #taskList.sort(key=lambda t: datetime.timedelta(t.priority*365*10) + (t.duedate - datetime.datetime.now()))
        taskList.sort(key=lambda t: t.assigner)
        maxTaskLength = max(len(t.name) for t in taskList)
        for t in taskList:
            timeToGo = self.timedeltaToHoursString(t.estimatedtime - t.timespent)
            timeTillDue = self.timedeltaToDaysString(t.duedate - datetime.datetime.now())
            print timeToGo+'\t'+str(t.priority)+'\t'+(t.name + ' '*maxTaskLength)[:maxTaskLength]+'\t'+t.assigner
            print '\t'+t.description+'\n'

    def timedeltaToDaysString(self, td):
        if abs(td) < datetime.timedelta(1):
            output = str(abs(td).seconds / 3600)+':'+('00'+str(abs(td).seconds / 60))[-2:]
        else:
            output = str(abs(td).days)+' days'
#            output = str(abs(td).days)+' days, '+('00'+str(abs(td).seconds / 3600))[-2:]+':'+('00'+str(abs(td).seconds / 60))[-2:]
        if td < datetime.timedelta(0):
            # overdue timedelta
            return 'overdue by '+output
        else:
            return output

    def timedeltaToHoursString(self, td):
        s = td.seconds +  24 * 60 * 60 * td.days
        h = s / 60 / 60
        m = int(s / 60 % 60)
        return str(h)+':'+('00'+str(m))[-2:]

    def do_graphTasks(self, arg):
        pass

    def do_workedOn(self, arg):
        "doesn't do anything yet"
        return parse.parseTimeInterval(arg)

    def do_updateTimeSpent(self, arg):
        if not self.selectedTask:
            print 'select a task first'
            return
        self.selectedTask.timespent = hours.getHoursWorked(self.selectedTask.id)
        print self.selectedTask.timespent
        self.selectedTask.put()
        self.taskList = task.createTasks()

    def do_clockHours(self, arg):
        if not self.selectedTask:
            print 'select a task first'
            return
        if arg and len(arg.split()) % 2 == 0:
            hours.clockTime(self.selectedTask.id,
                            title=self.selectedTask.name,
                            description=self.selectedTask.description,
                            startDatetime=parse.parseTimeInterval(' '.join(arg.split()[:len(arg.split()/2)])), 
                            endDatetime=parse.parseTimeInterval(' '.join(arg.split()[arg.split()/2:]))
            )
        else:
            hours.clockTime(self.selectedTask.id, title=self.selectedTask.name, description=self.selectedTask.description)
        print 'hours clocked'

    def do_clear(self, arg):
        for i in range(100):
            print ''

    def do_hours(self, arg):
        pprint([(t.name, t.timespent) for t in self.taskList])

if __name__ == '__main__':
    cli = EditTasksCLI()
    cli.cmdloop()
