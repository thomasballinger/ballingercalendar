#!/projects/schiz/software/LabPython/Python-2.6.3/python
# edittask
# being updated for use with spreadsheet-based tasks
# thomasballinger@gmail.com

import os, sys, optparse
sys.path = ['/projects/schiz/ra/tomb/python']+sys.path+['/projects/schiz/ra/tomb/scripts']
import datetime, parse
import spreadsheetTask as task
import calendarHours as hours
origDir = os.getcwd()
scriptFile = os.path.abspath(__file__)
scriptDir = os.path.basename(scriptFile)
import cmd
from pprint import pprint

class EditTasksCLI(cmd.Cmd):
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.prompt = ':) '
        self.selectedTask = None
        self.taskList = task.createTasks()

    def do_updateLocalTasklist(self, arg):
        self.taskList = task.createTasks()

    def do_exit(self, arg):
        sys.exit(0)

    def do_quit(self, arg):
        sys.exit(0)

    def do_EOF(self, arg):
        print('')
        return True

    def do_listtasks(self, arg):
        print self.taskList

    def do_task(self, arg):
        if arg:
            arg = arg.replace('_',' ')
            l = [x for x in self.taskList if x.name == arg]
            if not l:
                print('no such task')
                return
            self.selectedTask = l[0]
            print(self.selectedTask)
        elif self.selectedTask:
            print(self.selectedTask)
        else:
            print('select a task, or create a new one')

    def complete_task(self, text, line, beginindex, endindex):
        if not text:
            a = [x.name.replace(' ','_') for x in self.taskList]
            return a
        else:
            a = [x.name.replace(' ','_') for x in [t for t in self.taskList if t.name.replace(' ','_').startswith(text)]]
            return a

    def do_rename(self,arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        self.selectedTask.name = arg.replace('_',' ')
        self.selectedTask.put()

    def do_newtask(self,arg):
        if not arg:
            arg = raw_input('task name:')
            if not arg:
                print('nm')
                return False
        t = task.newTask(arg.replace('_',' '))
        self.selectedTask = t

    def do_description(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        if not arg:
            pprint('description:'+self.selectedTask.description)
            return
        self.selectedTask.description = arg
        self.selectedTask.put()

    def do_due(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        if not arg:
            print'due date:',self.selectedTask.duedate
            return
        time = parse.parseDate(arg)
        self.selectedTask.duedate = time
        print 'due date:',time
        self.selectedTask.put()

    def do_assigner(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        if not arg:
            print 'assigner:',self.selectedTask.assigner
            return
        self.selectedTask.assigner = arg
        self.selectedTask.put()

    def do_whose(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        if not arg:
            print 'whose:',self.selectedTask.whose
            return
        self.selectedTask.whose = arg
        self.selectedTask.put()

    def do_priority(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        if not arg:
            print 'priority:',self.selectedTask.priority
            return
        if not -1<int(arg)<10:
            print('bad priority value')
            return
        self.selectedTask.priority = int(arg)
        self.selectedTask.put()

    def do_estimatedTime (self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        if not arg:
            print 'estimated time:',self.selectedTask.estimatedtime
            return
        timedelta = parse.parseTimedelta(arg)
        self.selectedTask.estimatedtime = timedelta
        self.selectedTask.put()
        print 'estimated time:',self.selectedTask.estimatedtime

    def do_timeSpent(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        if not arg:
            print 'time spend:',self.selectedTask.timeSpent
            return
        interval = parse.parseTimeInterval(arg)
        self.selectedTask.timeSpend.append()
        self.selectedTask.put()
        print 'time spend:',self.selectedTask.timeSpent

    def do_wait(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        if not arg:
            print 'waits:',self.selectedTask.waits
            return
        self.selectedTask.waits.append(task.Wait())
        self.selectedTask.waits[-1].whatFor = arg
        selectedTask.put()
        print 'waits:',self.selectedTask.waits

    def do_appointment(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        self.selectedTask.isAppointment = True
        self.selectedTask.put()
        print 'task is now an appointment'

    def do_notAppointment(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        self.selectedTask.isAppointment = False
        self.selectedTask.put()
        print 'task is now not an appointment'

    def do_notComplete(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        self.selectedTask.isCompleted= False
        self.selectedTask.put()

    def do_complete(self, arg):
        if not self.selectedTask:
            print('choose a task first')
            return
        self.selectedTask.isCompleted= True
        self.selectedTask.put()

    def do_showCurrentTask(self, arg):
        if not self.selectedTask:
            print 'select a task first'
            return
        t = self.selectedTask
        print(t.name)
        for (label,prop) in zip(
        ['desc:','due:','assigned by:','priority:','time estimate:','time spent','start time','waits','is appointment:','is complete:'],
        [t.description, t.duedate, t.assigner, t.priority, t.estimatedtime, t.timespent, t.starttime, t.waitids, t.isAppointment, t.isCompleted]):
            if prop:
                print label,prop

    def do_removeTask(self, arg):
        if not self.selectedTask:
            print 'select a task first'
            return
        check = parse.parseBoolean(raw_input('really delete task'+self.selectedTask.__repr__()+'?\n'))
        if check:
            task.deleteTask(self.selectedTask)
            self.selectedTask = None

    def do_listChronologicallyByDueDate(self, arg):
        pprint(task.getTheStack(self.taskList))

    def do_listOverdue(self, arg):
        pprint([t for t in self.taskList if t.duedate < datetime.datetime.now() and not t.isCompleted])

    def do_listCompleted(self, arg):
        pprint([t for t in self.taskList if t.isCompleted])

    def do_listInProgress(self, arg):
        pprint([t for t in self.taskList if not t.isCompleted])

    def do_graphTasks(self, arg):
        pass

    def do_workedOn(self, arg):
        "doesn't do anything yet"
        return parse.parseTimeInterval(arg)

    def do_updateTimeSpent(self, arg):
        if not self.selectedTask:
            print 'select a task first'
            return
        self.selectedTask.timespent = hours.getHoursWorked(self.selectedTask.id)
        print self.selectedTask.timespent
        self.selectedTask.put()

    def do_clockHours(self, arg):
        if not self.selectedTask:
            print 'select a task first'
            return
        if arg and len(arg.split()) % 2 == 0:
            hours.clockTime(self.selectedTask.id,
                            title=self.selectedTask.name,
                            description=self.selectedTask.description,
                            startDatetime=parse.parseTimeInterval(' '.join(arg.split()[:len(arg.split()/2)])), 
                            endDatetime=parse.parseTimeInterval(' '.join(arg.split()[arg.split()/2:]))
            )
        else:
            hours.clockTime(self.selectedTask.id, title=self.selectedTask.name, description=self.selectedTask.description)
        print 'hours clocked'

    def do_clear(self, arg):
        for i in range(100):
            print ''

if __name__ == '__main__':
    cli = EditTasksCLI()
    cli.cmdloop()
